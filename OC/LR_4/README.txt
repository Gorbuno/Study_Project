Поскольку именованные семафоры используются для координации взаимодействия процессов, 
то для выполнения работы необходимо написать две программы.

Вторая программа – точная копия первой. Поэтому реально надо написать одну программу, 
скопировать ее с другим именем и поменять в ней запись символа ‘1’ на запись символа ‘2’.

Необходимо выбрать общий ресурс – файл и осуществлять запись данных в него из двух программ.

Каждая программа запускается в отдельном терминале. То есть экран в данном случае не является общим ресурсом. 
Общим ресурсом будет только файл.

Но для наблюдения за работой программ в каждой программе необходимо сделать вывод символа не только в файл,
но и на экран своего терминала.

Обе программы должны создать (или открыть, если создан) один и тот же именованный семафор, 
должны создать (или открыть, если создан) один и тот же файл, но записывать в файл разные символы.

В двух разных программах семафор становится общим, если у него одинаковое имя – первый параметр функции sem_open(). 
Обратите внимание на требование к имени семафора – оно должно быть в форме /somename, т.е. первый символ - слэш.

Необходимо убедиться, что в случае отсутствия именованного семафора процессы выводят символы в файл в произвольном порядке, например, так:

1212121212121212121212121212121212121212121212121212121212121

В случае использования именованного семафора процессы выводят символы в файл в определенном порядке, например, так:

111111111122222222221111111111222222222211111111112222222222

Результат должен быть примерно таким:

Открываете один терминал и запускаете программу. 
Она выводит символ ‘1’ на экран и в файл.

Открываете второй терминал и запускаете вторую программу. 
Она выводит на экран и в файл символ ‘2’.

Но, поскольку работает общий семафор, программы будут осуществлять вывод по очереди:
сначала первая программа выводит единицы в свой терминал (например, 10 раз), 
затем вторая программа выводит двойки в свой терминал (тоже 10 раз). А файл заполняется так, как показано выше.

Для наблюдения за записью в файл надо открыть третий терминал и ввести в нем следующую команду:

tail –f filename.

где filename – это имя файла, в который вы пишете символы.

На экране этого терминала вы увидите, заполнение файла символами ‘1’ и ‘2’ в темпе реального времени.

В конце работы программы семафор надо удалить.

Поскольку в этой работе мы используем семафорную операцию sem_wait() (с блокировкой), 
то при завершении одной программы вторая может зависнуть в этой операции. 
Выходом из такой ситуации является аварийное завершение программы (ctrl + с). 
В этом случае семафор может оказаться не удалённым и, более того, может оказаться в запертом состоянии. 
Тогда повторно запустить программу не удастся. В ОС Linux семафоры – это файлы в каталоге /dev/shm. 
Вы можете войти в этот каталог и вручную удалить семафор.

Программа может быть реализована в одном из двух вариантов.

Первый вариант программы – это когда цикл записи символа в файл и на экран помещен в отдельный поток. 
В этом случае архитектура программы будет похожа на архитектуру предыдущих программ: функция getchar() в main() выполняется с блокировкой, 
а поток создается в единственном экземпляре. Поскольку поток один, то появляется закономерный вопрос – может быть он вообще не нужен. 
Строго говоря, их два – один работает, другой следит за нажатием клавиши. Если поток не нужен, то как выполнять работу (запись в файл) 
и одновременно следить за нажатием клавиши. Здесь как раз и появляется второй вариант.

Второй вариант программы без потоков (или с одним потоком main) – это когда цикл записи помещен
 в основную программу. Но чтобы цикл выполнялся и одновременно проверял нажатие клавиши, необходимо функцию getchar() 
реализовать без блокировки. 
Реализовать построение минимального остовного дерева для графа, содержащего 15 вершин, по алгоритму Краскала.

1. Предварительный этап.

Программа должна сформировать матрицу весов ребер графа, содержащего 15 вершин, случайным образом, исходя из следующих условий:
	ребро создается с вероятностью 1/3 (в среднем в графе должно быть сформировано около 15х14/2/3=35 ребер)
	вес ребра – случайное целое число из диапазона [1..50]
	ВНИМАНИЕ! граф – неориентированный, любые действия над ребрами необходимо выполнять только один раз! (если какое-то действие произведено над парой вершин (4;7), его не нужно повторять для пары вершин (7;4) – их соединяет то же самое ребро)  
	для того, чтобы гарантировать связность полученного графа, для каждой пары вершин (K;K+1) (например, (1;2), (2;3), …, (9;10) и т.д.), если между ними не оказалось ребра, созданного в первой части процесса генерации, добавляется ребро веса 200 (тем самым по всему графу проходит цепочка ребер, однако, у них очень большие веса и выбраны в дерево они будут скорее всего только, если первоначально сформированный граф оказался несвязным).
По окончанию генерации программа должна вывести построчно список всех ребер (вес, номера вершин концов).

2. Генерация минимального остовного дерева по алгоритму Краскала.

Программа может представлять собой любую «наивную» реализацию алгоритма, например, следующую:

	массив, содержащий все ребра, упорядочивается по неубыванию весов
	в отдельном массиве длины 15 каждой вершине присваивается уникальное число (идентификатор компоненты связности, которой она принадлежит), например, порядковый номер
	в цикле извлекается очередное ребро из упорядоченного массива и осуществляется проверка, что его концы принадлежат разным компонентам связности:
o	если это не так, алгоритм переходит к следующему ребру
o	если это так, происходит включение ребра в остовное дерево (вывод на экран), а две компоненты связности объединяются в одну (например, цикл по всем вершинам ищет вершины, имеющие идентификатор второй компоненты, и заменяет его на идентификатор первой компоненты) 

К защите принимаются более сложные реализации алгоритма, при условии, что они разработаны самостоятельно.

На каждой итерации программа должна выводить на экран:
	номер итерации
	сведения о выбранном к включению ребре (вес и номера вершин его концов)
	список номеров вершин в объединяемых компонентах связности (отдельно для первой компоненты и отдельно для второй)

В конце работы программы она должна вывести сумму весов включенных ребер.
